<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>FlipDot Editor</title>
  <style>
    body { background:#111; color:#ddd; font-family:system-ui,Segoe UI,Roboto,Arial; margin:0; padding:20px; }
    h1 { margin:0 0 12px 0; }
    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:16px; }
    label { font-size:13px; }
    input[type=number] { width:80px; }
    .canvas-wrap { background:#000; padding:12px; display:inline-block; border-radius:8px; }
    canvas { display:block; background:#000; image-rendering:pixelated; }
    .btn { background:#222; border:1px solid #333; color:#ddd; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .btn:hover { filter:brightness(1.1); }
    .small { font-size:13px; opacity:0.9 }
    footer { margin-top:14px; color:#999; font-size:13px }
  </style>
</head>
<body>
  <h1>FlipDot Editor</h1>
  <div class="controls">
    <label>Width (dots): <input id="gridW" type="number" min="1" max="200" value="32"></label>
    <label>Height (dots): <input id="gridH" type="number" min="1" max="200" value="16"></label>
    <label>Dot size (px): <input id="dotSize" type="number" min="4" max="64" value="16"></label>
    <label>Active color: <input id="activeColor" type="color" value="#00ff88"></label>
    <label>Off color: <input id="offColor" type="color" value="#777777"></label>
    <button id="buildBtn" class="btn">Build Grid</button>
    <button id="clearBtn" class="btn">Clear</button>
    <button id="invertBtn" class="btn">Invert</button>
    <button id="exportBtn" class="btn">Export PNG</button>
    <span class="small">(Background of display is black)</span>
  </div>

  <div class="canvas-wrap" id="canvasWrap">
    <canvas id="flipCanvas" width="512" height="256"></canvas>
  </div>

  <div style="margin-top:12px">
    <span id="status" class="small"></span>
  </div>

  <footer>
    FlipDot Renderer & Editor By LunaTW :)<br>
    Click or drag to toggle dots. Hold Shift to force-off. Shift+Click will turn a dot off. Ctrl/Cmd+Click will toggle a cell to the other color.
  </footer>

<script>
(() => {
  const canvas = document.getElementById('flipCanvas');
  const ctx = canvas.getContext('2d');
  const gridWInput = document.getElementById('gridW');
  const gridHInput = document.getElementById('gridH');
  const dotSizeInput = document.getElementById('dotSize');
  const activeColorInput = document.getElementById('activeColor');
  const offColorInput = document.getElementById('offColor');
  const buildBtn = document.getElementById('buildBtn');
  const clearBtn = document.getElementById('clearBtn');
  const invertBtn = document.getElementById('invertBtn');
  const exportBtn = document.getElementById('exportBtn');

  let gridW = parseInt(gridWInput.value,10);
  let gridH = parseInt(gridHInput.value,10);
  let dotSize = parseInt(dotSizeInput.value,10);
  let activeColor = activeColorInput.value;
  let offColor = offColorInput.value;
  let grid = [];
  let isMouseDown = false;
  let drawValue = null;

  function buildGrid(w,h,d) {
    gridW = w; gridH = h; dotSize = d;
    const padding = 8;
    canvas.width = gridW * dotSize + padding*2;
    canvas.height = gridH * dotSize + padding*2;
    grid = Array.from({length:gridH}, () => Array.from({length:gridW}, () => false));
    render();
  }

  function render() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const padding = 8;
    for (let y=0;y<gridH;y++){
      for (let x=0;x<gridW;x++){
        const cx = padding + x*dotSize + dotSize/2;
        const cy = padding + y*dotSize + dotSize/2;
        const r = Math.floor(dotSize*0.45);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI*2);
        ctx.closePath();
        ctx.fillStyle = grid[y][x] ? activeColor : offColor;
        ctx.fill();
      }
    }
  }

  function posToCell(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const padding = 8;
    const cx = clientX - rect.left;
    const cy = clientY - rect.top;
    const x = Math.floor((cx - padding) / dotSize);
    const y = Math.floor((cy - padding) / dotSize);
    if (x<0||x>=gridW||y<0||y>=gridH) return null;
    return {x,y};
  }

  canvas.addEventListener('mousedown', (e) => {
    const cell = posToCell(e.clientX, e.clientY);
    if (!cell) return;
    isMouseDown = true;
    drawValue = !grid[cell.y][cell.x];
    grid[cell.y][cell.x] = drawValue;
    render();
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isMouseDown) return;
    const cell = posToCell(e.clientX, e.clientY);
    if (!cell) return;
    if (grid[cell.y][cell.x] !== drawValue) {
      grid[cell.y][cell.x] = drawValue;
      render();
    }
  });

  window.addEventListener('mouseup', () => {
    isMouseDown = false;
    drawValue = null;
  });

  buildBtn.addEventListener('click', ()=>{
    const w = Math.max(1, Math.min(200, parseInt(gridWInput.value,10)||32));
    const h = Math.max(1, Math.min(200, parseInt(gridHInput.value,10)||16));
    const d = Math.max(4, Math.min(64, parseInt(dotSizeInput.value,10)||16));
    buildGrid(w,h,d);
  });
  clearBtn.addEventListener('click', ()=>{ for(let y=0;y<gridH;y++) for(let x=0;x<gridW;x++) grid[y][x]=false; render(); });
  invertBtn.addEventListener('click', ()=>{ for(let y=0;y<gridH;y++) for(let x=0;x<gridW;x++) grid[y][x]=!grid[y][x]; render(); });

  activeColorInput.addEventListener('input', ()=>{ activeColor = activeColorInput.value; render(); });
  offColorInput.addEventListener('input', ()=>{ offColor = offColorInput.value; render(); });
  dotSizeInput.addEventListener('change', ()=>{ dotSize = parseInt(dotSizeInput.value,10)||16; buildGrid(gridW, gridH, dotSize); });

  exportBtn.addEventListener('click', ()=>{
      const padding = 8;
      const w = gridW * dotSize;
      const h = gridH * dotSize;
    
      const trimmedCanvas = document.createElement('canvas');
      trimmedCanvas.width = w;
      trimmedCanvas.height = h;
      const tctx = trimmedCanvas.getContext('2d');
    
      tctx.fillStyle = '#000';
      tctx.fillRect(0,0,w,h);
      for (let y=0;y<gridH;y++){
        for (let x=0;x<gridW;x++){
          const cx = x*dotSize + dotSize/2;
          const cy = y*dotSize + dotSize/2;
          const r = Math.floor(dotSize*0.45);
          tctx.beginPath();
          tctx.arc(cx, cy, r, 0, Math.PI*2);
          tctx.closePath();
          tctx.fillStyle = grid[y][x] ? activeColor : offColor;
          tctx.fill();
        }
      }
    
      const url = trimmedCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flipdot.png';
      a.click();
    });


  buildGrid(gridW, gridH, dotSize);
})();
</script>
</body>
</html>
