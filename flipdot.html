<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>FlipDot Editor</title>
  <style>
    @font-face {
      font-family: 'Luminator';
      src: url('luminator-10x16-dotmap.otf') format('opentype');
    }

    body { background:#111; color:#ddd; font-family:system-ui,Segoe UI,Roboto,Arial; margin:0; padding:20px; }
    h1 { margin:0 0 12px 0; }
    .controls { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:16px; }
    label { font-size:13px; }
    input[type=number], input[type=text] { width:80px; }
    .canvas-wrap { background:#000; padding:12px; display:inline-block; border-radius:8px; }
    canvas { display:block; background:#000; image-rendering:pixelated; }
    .btn { background:#222; border:1px solid #333; color:#ddd; padding:8px 12px; border-radius:6px; cursor:pointer; }
    .btn:hover { filter:brightness(1.1); }
    .small { font-size:13px; opacity:0.9 }
    footer { margin-top:14px; color:#999; font-size:13px }
    dialog { background:#222; color:#ddd; border:none; border-radius:8px; padding:20px; }
    dialog input { margin:4px 0; }
    dialog button { margin-top:8px; }
  </style>
</head>
<body>
  <h1>FlipDot Editor</h1>
  <div class="controls">
    <label>Width (dots): <input id="gridW" type="number" min="1" max="200" value="32"></label>
    <label>Height (dots): <input id="gridH" type="number" min="1" max="200" value="16"></label>
    <label>Dot size (px): <input id="dotSize" type="number" min="4" max="64" value="16"></label>
    <label>Active color: <input id="activeColor" type="color" value="#00ff88"></label>
    <label>Off color: <input id="offColor" type="color" value="#272727"></label>
    <button id="buildBtn" class="btn">Build Grid</button>
    <button id="clearBtn" class="btn">Clear</button>
    <button id="invertBtn" class="btn">Invert</button>
    <button id="textBtn" class="btn">Add Text</button>
    <button id="exportBtn" class="btn">Export PNG</button>
  </div>

  <div class="canvas-wrap">
    <canvas id="flipCanvas" width="512" height="256"></canvas>
  </div>

  <footer>
    FlipDot Renderer & Editor By LunaTW :)<br>
    Click or drag to toggle dots. Hold Shift to force-off. Ctrl/Cmd+Click toggles.
  </footer>

  <!-- Text Input Dialog -->
  <dialog id="textDialog">
    <h3>Add Text</h3>
    <label>Text: <input id="textContent" type="text" value="Hello!"></label><br>
    <label>X (dot): <input id="textX" type="number" value="0"></label><br>
    <label>Y (dot): <input id="textY" type="number" value="0"></label><br>
    <label>Font size (dot scale): <input id="textSize" type="number" min="4" max="64" value="8"></label><br>
    <label><input type="checkbox" id="textCenterX"> Center X</label><br>
    <label><input type="checkbox" id="textCenterY"> Center Y</label><br>
    <button id="applyTextBtn" class="btn">Apply</button>
    <button id="cancelTextBtn" class="btn">Cancel</button>
  </dialog>

<script>
(() => {
    // --- 1. Element References ---
    const canvas = document.getElementById('flipCanvas');
    const ctx = canvas.getContext('2d');
    const gridWInput = document.getElementById('gridW');
    const gridHInput = document.getElementById('gridH');
    const dotSizeInput = document.getElementById('dotSize');
    const activeColorInput = document.getElementById('activeColor');
    const offColorInput = document.getElementById('offColor');
    const buildBtn = document.getElementById('buildBtn');
    const clearBtn = document.getElementById('clearBtn');
    const invertBtn = document.getElementById('invertBtn');
    const exportBtn = document.getElementById('exportBtn');
    const textBtn = document.getElementById('textBtn');
    const textDialog = document.getElementById('textDialog');
    const textContentInput = document.getElementById('textContent');
    const textXInput = document.getElementById('textX');
    const textYInput = document.getElementById('textY');
    const textSizeInput = document.getElementById('textSize');
    const applyTextBtn = document.getElementById('applyTextBtn');
    const cancelTextBtn = document.getElementById('cancelTextBtn');
    const textCenterY = document.getElementById('textCenterY'); // <-- ADD THIS LINE
    // --- 2. State Variables (Initialized for immediate display) ---
    let gridW, gridH, dotSize;
    let activeColor = activeColorInput?.value || '#FFFFFF'; // Read default color
    let offColor = offColorInput?.value || '#333333';     // Read default color
    let grid = [];
    let isMouseDown = false;
    let drawValue = null;
    // --- 3. Core Functions ---
    function buildGrid(w,h,d) {
      gridW = w; gridH = h; dotSize = d;
      const padding = 8;
      canvas.width = gridW * dotSize + padding*2;
      canvas.height = gridH * dotSize + padding*2;
      grid = Array.from({length:gridH}, () => Array.from({length:gridW}, () => false));
      render();
    }
    function render() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      const padding = 8;
      for (let y=0;y<gridH;y++){
        for (let x=0;x<gridW;x++){
          const cx = padding + x*dotSize + dotSize/2;
          const cy = padding + y*dotSize + dotSize/2;
          const r = Math.floor(dotSize*0.45);
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI*2);
          ctx.closePath();
          // Uses initialized activeColor/offColor
          ctx.fillStyle = grid[y][x] ? activeColor : offColor;
          ctx.fill();
        }
      }
    }
    function posToCell(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const padding = 8;
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      const x = Math.floor((cx - padding) / dotSize);
      const y = Math.floor((cy - padding) / dotSize);
      if (x<0||x>=gridW||y<0||y>=gridH) return null;
      return {x,y};
    }
    // --- 4. Event Listeners (Canvas Interaction) ---
    canvas.addEventListener('mousedown', (e) => {
      const cell = posToCell(e.clientX, e.clientY);
      if (!cell) return;
      isMouseDown = true;
      drawValue = !grid[cell.y][cell.x];
      grid[cell.y][cell.x] = drawValue;
      render();
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!isMouseDown) return;
      const cell = posToCell(e.clientX, e.clientY);
      if (!cell) return;
      if (grid[cell.y][cell.x] !== drawValue) {
        grid[cell.y][cell.x] = drawValue;
        render();
      }
    });
    window.addEventListener('mouseup', () => {
      isMouseDown = false;
      drawValue = null;
    });
    buildBtn.addEventListener('click', ()=>{
      const w = Math.max(1, Math.min(500, parseInt(gridWInput.value,10)||32)); // Changed 200 to 500
      const h = Math.max(1, Math.min(200, parseInt(gridHInput.value,10)||16));
      const d = Math.max(4, Math.min(64, parseInt(dotSizeInput.value,10)||16));
      buildGrid(w,h,d);
    });
    clearBtn.addEventListener('click', ()=>{ for(let y=0;y<gridH;y++) for(let x=0;x<gridW;x++) grid[y][x]=false; render(); });
    invertBtn.addEventListener('click', ()=>{ for(let y=0;y<gridH;y++) for(let x=0;x<gridW;x++) grid[y][x]=!grid[y][x]; render(); });
    activeColorInput.addEventListener('input', ()=>{ activeColor = activeColorInput.value; render(); });
    offColorInput.addEventListener('input', ()=>{ offColor = offColorInput.value; render(); });
    dotSizeInput.addEventListener('change', ()=>{ dotSize = parseInt(dotSizeInput.value,10)||16; buildGrid(gridW, gridH, dotSize); });
    exportBtn.addEventListener('click', ()=>{
      const padding = 8;
      const w = gridW * dotSize;
      const h = gridH * dotSize;
      const trimmedCanvas = document.createElement('canvas');
      trimmedCanvas.width = w;
      trimmedCanvas.height = h;
      const tctx = trimmedCanvas.getContext('2d');
      tctx.fillStyle = '#000';
      tctx.fillRect(0,0,w,h);
      for (let y=0;y<gridH;y++){
        for (let x=0;x<gridW;x++){
          const cx = x*dotSize + dotSize/2;
          const cy = y*dotSize + dotSize/2;
          const r = Math.floor(dotSize*0.45);
          tctx.beginPath();
          tctx.arc(cx, cy, r, 0, Math.PI*2);
          tctx.closePath();
          tctx.fillStyle = grid[y][x] ? activeColor : offColor;
          tctx.fill();
        }
      }
      const url = trimmedCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flipdot.png';
      a.click();
    });
    textBtn.addEventListener('click', () => textDialog?.showModal());
    cancelTextBtn.addEventListener('click', () => textDialog?.close());

    applyTextBtn.addEventListener('click', () => {
        if (!textContentInput) return;
    
        // Force uppercase immediately
        const textA = textContentInput.value.toUpperCase(); 
        const startX = parseInt(textXInput.value, 10) || 0;
        let startY = parseInt(textYInput.value, 10) || 0; // Use 'let' so it can be overwritten
        const size = parseInt(textSizeInput.value, 10) || 8;
        const centerX = document.getElementById('textCenterX').checked;
        const centerY = textCenterY.checked; // <-- READ THE NEW CHECKBOX
    
        // Variables defined once
        let currentSpacing = 0; // in pixels
        const regex = /^<S(-?\d+)>/i; 
        let i = 0; // Character index
    
        // Temporary canvas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = gridW * dotSize;
        tempCanvas.height = gridH * dotSize;
        const tctx = tempCanvas.getContext('2d');
    
        tctx.fillStyle = '#000';
        tctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        tctx.fillStyle = '#fff';
        tctx.font = `${size * dotSize}px 'Luminator'`;
        tctx.textBaseline = 'top';
        tctx.textAlign = 'left';
    
        // --- Vertical Centering ---
        if (centerY) {
            const textHeight = size * dotSize; // Total text height in pixels
            // Calculate the difference between grid height and text height, and divide by 2
            // We set startY to the resulting offset in *dot units*
            startY = Math.floor(((gridH * dotSize) - textHeight) / (2 * dotSize));
            if (startY < 0) startY = 0; // Prevent negative startY if text is too large
        }
        // --- End Vertical Centering ---
    
    
        // --- 1. Calculate Centering Offset (Horizontal) ---
        let offsetX = startX * dotSize;
        if (centerX) {
            // ... (Centering logic remains unchanged from the previous fix) ...
            const measureCtx = document.createElement('canvas').getContext('2d');
            measureCtx.font = tctx.font;
    
            let totalWidth = 0;
            let spacing = 0;
            let charIndex = 0;
    
            while (charIndex < textA.length) {
                const substr = textA.substring(charIndex);
                const match = substr.match(regex);
                
                if (match) {
                    spacing = parseInt(match[1], 10) * dotSize;
                    charIndex += match[0].length;
                    continue;
                }
    
                const char = textA[charIndex];
                totalWidth += measureCtx.measureText(char).width + spacing;
                charIndex++;
            }
            
            offsetX = (gridW * dotSize - totalWidth) / 2;
        }
        
        // --- 2. Draw Text to Temp Canvas ---
        currentSpacing = 0; 
        i = 0;
        
        while (i < textA.length) {
            const substr = textA.substring(i);
            const match = substr.match(regex);
            
            if (match) {
                currentSpacing = parseInt(match[1], 10) * dotSize;
                offsetX += currentSpacing; // Apply spacing shift immediately
                i += match[0].length;
                continue;
            }
    
            const char = textA[i];
            
            // Draw the character using the potentially centered startY
            tctx.fillText(char, offsetX, startY * dotSize); 
            
            // Advance the offset by the character width only
            const charWidth = tctx.measureText(char).width;
            offsetX += charWidth;
            
            i++;
        }
    
        // --- 3. Merge temp canvas into grid (faster center sampling) ---
        const imgData = tctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
    
        for (let y = 0; y < gridH; y++) {
            for (let x = 0; x < gridW; x++) {
                const sampleX = Math.floor(x * dotSize + dotSize / 2);
                const sampleY = Math.floor(y * dotSize + dotSize / 2);
                const idx = (sampleY * tempCanvas.width + sampleX) * 4;
    
                if (imgData[idx] > 128) {
                    grid[y][x] = true; 
                }
            }
        }
    
        render();
        textDialog?.close();
    });
    
      // --- 7. Initialization (Called once on load) ---
      buildBtn.click();

})();
</script>
</body>
</html>
